package Ch_3_2_Binary_Search_Trees;

public class Practise_3_2_05 {
    public static void main(String[] args) {
        /*
         * 这道题的意思，我理解是相当于对双主键的序列排序，一个主键是查找频率，一个主键是使二叉树保持结构的键
         * 
         * 二叉查找树之所以能保持高效，是因为每次比较后，所需要查找的规模都比之前减少了一半
         * 比如进入了右子树，那其实相当于左子树都不可能，排除了一半的情况，每次比较都如此
         * 
         * 假如我们按照查找频率的顺序插入，很可能使二叉查找树退化成但链表的线性结构
         * 
         * 比如(括号中代表查找频率) 10(10) 9(9) 8(8) 7(7) 6(6) 5(5) 4(4)
         * 
         * 假如按照查找频率插入，我们得到了一棵单链表树，即使可以保证最高查找频率的几个结点能在接近常数
         * 时间内被查找到，但是却让最低查找频率的结点在接近线性时间内才能被查找到，感觉这和二叉查找树
         * 的精神背道而驰啊...因此我认为构造顺序一定是要以除查找频率外另一个主键为主，尽量构造出一棵
         * 树高最小的树
         * 
         * 
         * 
         * 
         */
    }
}
