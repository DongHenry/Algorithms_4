package 第二章_初级排序算法;

import static 第二章_初级排序算法.Text_Array.*;
import edu.princeton.cs.algs4.*;

public class Practise_2_1_15 {
    public static long gcd(long p, long q) {
        while (q != 0) {
            long r = p % q;
            p = q;
            q = r;
        }
        return p;
    }
    private static long selectionExchange = 0;
    public static void selection(int[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++)
                if (a[j] < a[min]) min = j;
            selectionExchange++;
            int t = a[min];
            a[min] = a[i];
            a[i] = t;
        }   
    }
    private static long insertionExchange = 0;
    public static void insertion(int[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++)
            for (int j = i; j > 0 && a[j] < a[j - 1]; j--) {
                insertionExchange++;
                int t = a[j];
                a[j] = a[j - 1];
                a[j - 1] = t;
            }  
    }
    private static long shellExchange = 0;
    public static void shell(int[] a) {
        int N = a.length, h = 1;
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            for (int i = h; i < N; i++) 
                for (int j = i; j >= h && a[j] < a[j - h]; j -= h) {
                    shellExchange++;
                    int t = a[j];
                    a[j] = a[j - h];
                    a[j - h] = t;
                }
            h /= 3;
        }
    }
    public static void test() {
        for (int i = 100; i < 10000; i += 100) {
            int[] arr = intRandom_size(i);
            int[] copy1 = intCopy_arr(arr);
            int[] copy2 = intCopy_arr(arr);
            selection(arr);
            insertion(copy1);
            shell(copy2);
            long g1 = gcd(selectionExchange, insertionExchange);
            long g2 = gcd(insertionExchange, shellExchange);
            long g3 = gcd(selectionExchange, shellExchange);
            long min = g1 < g2 ? (g1 < g3 ? g1 : g3) : (g2 < g3 ? g2 : g3);
            StdOut.printf("规模 %d 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = %d : %d : %d\n", 
                    i, selectionExchange / min, insertionExchange / min, shellExchange / min);
            selectionExchange = insertionExchange = shellExchange = 0;
        }
    }
    public static void main(String[] args) {
        /*
         * 应该用选择排序，不论在任何情况下，都只需要 N 次交换
         * 当我们考虑实际问题时，交换的次数小于等于 N, 
         * 毕竟如果查找的序列中没有比假定最小的小，那么不用自己和自己交换
         * 很显然，希尔排序和插入排序的交换次数都有可能大于 N
         */
        test();
    }
    // output
    /*
     *  规模 100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 50 : 1249 : 224
        规模 200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 200 : 10057 : 1006
        规模 300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 300 : 20051 : 1748
        规模 400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 100 : 9727 : 619
        规模 500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 100 : 11859 : 673
        规模 600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 200 : 30357 : 1387
        规模 700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 700 : 123845 : 5664
        规模 800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 800 : 163041 : 5727
        规模 900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 900 : 196013 : 6868
        规模 1000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 500 : 121685 : 4251
        规模 1100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1100 : 300837 : 9540
        规模 1200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1200 : 356279 : 9806
        规模 1300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1300 : 424043 : 10453
        规模 1400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 700 : 245229 : 5842
        规模 1500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1500 : 565537 : 13785
        规模 1600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 800 : 322762 : 6995
        规模 1700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1700 : 721739 : 13300
        规模 1800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1800 : 804865 : 14668
        规模 1900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1900 : 893508 : 16337
        规模 2000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2000 : 982703 : 19745
        规模 2100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2100 : 1069379 : 17672
        规模 2200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1100 : 590048 : 9919
        规模 2300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1150 : 668140 : 10293
        规模 2400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2400 : 1431568 : 23287
        规模 2500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2500 : 1533317 : 23265
        规模 2600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 325 : 214256 : 3121
        规模 2700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2700 : 1803250 : 26791
        规模 2800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 560 : 388511 : 4942
        规模 2900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2900 : 2054567 : 27135
        规模 3000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1500 : 1131852 : 13903
        规模 3100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 620 : 477465 : 6073
        规模 3200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3200 : 2578533 : 33597
        规模 3300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3300 : 2738205 : 36127
        规模 3400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1700 : 1457221 : 16724
        规模 3500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3500 : 3042087 : 34730
        规模 3600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3600 : 3237837 : 34648
        规模 3700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3700 : 3444408 : 38185
        规模 3800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 475 : 454866 : 5143
        规模 3900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3900 : 3770174 : 35717
        规模 4000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 800 : 803909 : 7842
        规模 4100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4100 : 4149538 : 41995
        规模 4200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4200 : 4461245 : 42043
        规模 4300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4300 : 4559439 : 43874
        规模 4400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4400 : 4840752 : 42003
        规模 4500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4500 : 5087465 : 43908
        规模 4600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 230 : 266273 : 2187
        规模 4700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4700 : 5481146 : 47973
        规模 4800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4800 : 5717321 : 52710
        规模 4900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4900 : 6001130 : 53163
        规模 5000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2500 : 3143941 : 25165
        规模 5100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5100 : 6605229 : 53783
        规模 5200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5200 : 6757115 : 59058
        规模 5300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2650 : 3498876 : 27663
        规模 5400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5400 : 7301992 : 56449
        规模 5500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5500 : 7623069 : 56534
        规模 5600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5600 : 7737956 : 56135
        规模 5700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5700 : 8116763 : 57714
        规模 5800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 2900 : 4189053 : 30662
        规模 5900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 5900 : 8521583 : 55510
        规模 6000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6000 : 9096867 : 62869
        规模 6100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6100 : 9366341 : 60360
        规模 6200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6200 : 9477127 : 65654
        规模 6300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6300 : 9889007 : 66126
        规模 6400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6400 : 10044791 : 70163
        规模 6500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6500 : 10665228 : 66291
        规模 6600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3300 : 5432375 : 34311
        规模 6700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6700 : 11098996 : 68557
        规模 6800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6800 : 11490544 : 69233
        规模 6900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 6900 : 12045958 : 75361
        规模 7000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3500 : 6101561 : 40176
        规模 7100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7100 : 12468339 : 77440
        规模 7200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7200 : 12586593 : 81935
        规模 7300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7300 : 13110967 : 78422
        规模 7400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7400 : 13763418 : 73667
        规模 7500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7500 : 13917434 : 82757
        规模 7600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3800 : 7139483 : 40036
        规模 7700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7700 : 14717089 : 82730
        规模 7800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 7800 : 15230939 : 81471
        规模 7900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 3950 : 7854522 : 44585
        规模 8000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8000 : 15884402 : 90435
        规模 8100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8100 : 16155501 : 94675
        规模 8200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8200 : 16860520 : 96439
        规模 8300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4150 : 8558102 : 46225
        规模 8400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8400 : 17431327 : 90003
        规模 8500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 4250 : 9070228 : 47041
        规模 8600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8600 : 18352659 : 99528
        规模 8700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8700 : 18809581 : 93427
        规模 8800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8800 : 19233155 : 94226
        规模 8900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 8900 : 19651957 : 103973
        规模 9000 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9000 : 20202433 : 103634
        规模 9100 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9100 : 20556946 : 105009
        规模 9200 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9200 : 21274229 : 106374
        规模 9300 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9300 : 21581917 : 114275
        规模 9400 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9400 : 22000828 : 103367
        规模 9500 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9500 : 22409964 : 101629
        规模 9600 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9600 : 22761559 : 119162
        规模 9700 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9700 : 23491867 : 123296
        规模 9800 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 1400 : 3453649 : 16576
        规模 9900 的交换数比为 -->  选择排序 : 插入排序 : 希尔排序 = 9900 : 24330727 : 117868
     */
}
